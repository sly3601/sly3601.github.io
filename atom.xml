<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>熠只猪の精神世界</title>
  
  <subtitle>The world needs more love.</subtitle>
  <link href="https://sly3601.top/atom.xml" rel="self"/>
  
  <link href="https://sly3601.top/"/>
  <updated>2024-10-24T18:16:13.822Z</updated>
  <id>https://sly3601.top/</id>
  
  <author>
    <name>熠只猪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【电路】PCB电流与信号完整性设计笔记</title>
    <link href="https://sly3601.top/posts/2e5f328.html"/>
    <id>https://sly3601.top/posts/2e5f328.html</id>
    <published>2024-10-07T07:46:31.000Z</published>
    <updated>2024-10-24T18:16:13.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PCB电流与信号完整性设计笔记"><a href="#PCB电流与信号完整性设计笔记" class="headerlink" title="PCB电流与信号完整性设计笔记"></a>PCB电流与信号完整性设计笔记</h1><h2 id="基本的电流概念"><a href="#基本的电流概念" class="headerlink" title="基本的电流概念"></a>基本的电流概念</h2><h3 id="介电常数"><a href="#介电常数" class="headerlink" title="介电常数"></a>介电常数</h3><p>电子在铜导线中的传输速度理论上是光速。</p><p>但问题是电流流过导体，会在导体周围产生电磁场，<code>电磁场和电流必须一起移动</code>，而磁场的移动速度是受到导体周围介质的影响的。<br>$$<br>信号传播速度 &#x3D; 11.8&#x2F;\sqrt{\varepsilon_r}    \rm in&#x2F;ns<br>$$<br>$$<br>\varepsilon_r是相对介电常数，也就是空气（真空）的介电常数，\varepsilon_r&#x3D;1<br>$$</p><p>像我们常用的PCB材料<code>FR4</code>的相对介电常数约为4，那套这个公式就是：<br>$$<br>FR4信号传播速度 &#x3D; 11.8&#x2F;2 \approx6    \rm in&#x2F;ns<br>$$<br>传输速度远小于在空气介质中。</p><h3 id="走线宽度和信号传输速度"><a href="#走线宽度和信号传输速度" class="headerlink" title="走线宽度和信号传输速度"></a>走线宽度和信号传输速度</h3><p>信号线越粗，传输速度越慢。</p><p>因为走线变宽走线和参考层之间就有更多磁场线包在介质中。</p><h3 id="微带线和带状线"><a href="#微带线和带状线" class="headerlink" title="微带线和带状线"></a>微带线和带状线</h3><img src="/img/photos/wdx.webp" alt="微带线" style="zoom:100%;" /><img src="/img/photos/dzx.webp" alt="带状线" style="zoom:100%;" /><ul><li><p>微带线就是一面是空气，另一面是参考层（应该是GND平面）的PCB信号线。</p></li><li><p>带状线就是两面都是参考层的信号线。</p></li></ul><h3 id="数字电路的时序问题"><a href="#数字电路的时序问题" class="headerlink" title="数字电路的时序问题"></a>数字电路的时序问题</h3><ul><li>RGB屏的信号线，要确保三种信号同时到达接收器。</li><li>差分对两条信号线必须等长。</li><li>当时钟脉冲触发时，数据线的正确电平必须出现并稳定在各自端口。</li></ul><p>解决这一问题的方法：<code>蛇形走线</code>，确保等长。</p><h2 id="实际PCB走线tips"><a href="#实际PCB走线tips" class="headerlink" title="实际PCB走线tips"></a>实际PCB走线tips</h2><ol><li><p>走线距离同层的地铜皮≥三倍线宽</p><img src="https://s2.loli.net/2024/10/23/jkmfMItQUB8VRgY.png" alt="微带线" style="zoom:100%;" /></li><li><p>避免高速信号跨区。一般高速线距离参考平面边缘大于40mil，但是实际案例一般是做不到。</p></li></ol><img src="https://s2.loli.net/2024/10/23/tvr7n3oC4NhVPOQ.png" alt="微带线" style="zoom:70%;" /><ol start="3"><li><p>芯片、ESD器件的每个GND焊盘附近都打一个GND通孔，并且尽量靠近焊盘。</p></li><li><p>避免在晶振周围、开关电源、磁类器件（电感）周围布线。</p></li><li><p>差分线等长：绕线补偿</p></li></ol><img src="https://s2.loli.net/2024/10/23/DmotdeYX67wFZ1p.png" alt="微带线" style="zoom:70%;" /><p>差分线对称：</p><img src="https://s2.loli.net/2024/10/24/aSBxvsZdCGlJWc5.png" alt="微带线" style="zoom:80%;" /><ol start="6"><li><p>完整地平面：<code>因为只有大面积且完整的铜箔才能提供阻抗极小的高频回流路径</code>。</p></li><li><p>回流地过孔：下图是不同频率的信号线下电流的分布密度。</p><img src="https://s2.loli.net/2024/10/24/oGSNxOquiwImUF3.png" alt="微带线" style="zoom:30%;" /></li></ol><p>伴地过孔的打法：</p><img src="https://s2.loli.net/2024/10/24/kAZTOg2Dna7Wi4w.png" alt="微带线" style="zoom:100%;" /><p>应用：uart串口线旁边：（其实RX右边也要打一个）</p><img src="https://s2.loli.net/2024/10/24/XhMxFjm6oHE9sWG.png" alt="微带线" style="zoom:60%;" /><ol start="8"><li><p>地铜皮不要超过地焊盘：</p><img src="https://s2.loli.net/2024/10/24/k2TJ1i5nuOhN7Lp.png" alt="微带线" style="zoom:70%;" /></li><li><p>重要的时钟信号、复位信号建议包地，包地线间隔500mil至少打一个地过孔，包地线距离信号线是3W。包地线线宽可取4mil~10mil。</p></li><li><p>蛇形走线建议形态：</p><img src="https://s2.loli.net/2024/10/24/Sy4QA3drqghfxk9.png" alt="微带线" style="zoom:70%;" /></li><li><p>尽量减小残桩长度，尽量为0。</p><img src="https://s2.loli.net/2024/10/24/KGtq5f3czSeuryR.png" alt="微带线" style="zoom:70%;" /></li><li><p>信号线一般是4mil。</p></li><li><p>纠正错误理念：<code>以下的通过过孔的直角走线是允许的：</code></p></li></ol><img src="https://s2.loli.net/2024/10/24/8lcTN7x6nPvCGJa.png" alt="微带线" style="zoom:70%;" /><p><code>以下的走线中间插过孔是被允许的：</code></p><img src="https://s2.loli.net/2024/10/24/Uuwo4lnrhdmACSj.png" alt="微带线" style="zoom:90%;" /><ol start="14"><li><p>信号+电源的过孔一般取0.4mm · 0.2mm，被简称为0402过孔，每个0402过孔大概能走0.4A的电流。所以走电源线要打孔时一般要多个过孔+铺铜。</p></li><li><p>大于30mil就不走线了，都改铺铜，那怎么确定线宽呢？ctrl+m（快捷键可能要自己设置）测量铺铜宽度并实时修改达到约数值即可：</p><img src="https://s2.loli.net/2024/10/24/yI4bKQx8X2U1sau.png" alt="微带线" style="zoom:80%;" /></li><li><p>芯片的电源pin尽量等于芯片焊盘的宽度，大于等于8mil，但是不能大于焊盘本身的宽度。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PCB电流与信号完整性设计笔记&quot;&gt;&lt;a href=&quot;#PCB电流与信号完整性设计笔记&quot; class=&quot;headerlink&quot; title=&quot;PCB电流与信号完整性设计笔记&quot;&gt;&lt;/a&gt;PCB电流与信号完整性设计笔记&lt;/h1&gt;&lt;h2 id=&quot;基本的电流概念&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="理论" scheme="https://sly3601.top/categories/%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="PCB" scheme="https://sly3601.top/tags/PCB/"/>
    
    <category term="电路" scheme="https://sly3601.top/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>C语言与数据结构的入门与持续精进</title>
    <link href="https://sly3601.top/posts/f50b84c9.html"/>
    <id>https://sly3601.top/posts/f50b84c9.html</id>
    <published>2024-10-06T07:46:31.000Z</published>
    <updated>2024-10-13T07:57:02.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode配置C语言环境"><a href="#vscode配置C语言环境" class="headerlink" title="vscode配置C语言环境"></a>vscode配置C语言环境</h1><p>MinGW-W64 GCC下载链接：</p><div class="tag link"><a class="link-card" title="MinGW-W64 GCC百度网盘下载，提取码unfm" href="https://pan.baidu.com/s/1ltlbxroX7v1SPZu1IPp9Zg"><div class="left"><img src="/img/siteicon/64.png"/></div><div class="right"><p class="text">MinGW-W64 GCC百度网盘下载，提取码unfm</p><p class="url">https://pan.baidu.com/s/1ltlbxroX7v1SPZu1IPp9Zg</p></div></a></div><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h3><p>strlen函数测量字符串长度：strlen(s)传入头指针。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针基础语法"><a href="#指针基础语法" class="headerlink" title="指针基础语法"></a>指针基础语法</h2><details class="folding-tag" green open><summary> 来自CSDN-唐大麦 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="type">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="type">int</span> *(*p(<span class="type">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>              </div>            </details><p>上面就已经把指针的语法说得相当明白了，无非就是各种符号的优先级问题，<code>优先级 () &gt; [] &gt; *</code>，哪一个符号先与变量结合，然后是哪一个，这样子再复杂的指针复合体也能迎刃而解。</p><h2 id="指针结合地址"><a href="#指针结合地址" class="headerlink" title="指针结合地址"></a>指针结合地址</h2><p>指针，当然会指向一个地方。</p><p>指针具体指向一个<code>地址</code>，这个地址我们就以stm32单片机为例，stm32内核是32位的系统，所以地址就是32位的，比如<code>0x12345678</code>，就是一个32位的地址，也就是4个字节。所以32位系统的指针都是4个字节的。</p><ul><li><p>32位系统中char占1个字节。</p></li><li><p>32位系统中short占2个字节。</p></li><li><p>32位系统中int占4个字节。</p></li></ul><h2 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h2><details class="folding-tag" green open><summary> 来自CSDN-唐大麦 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> *p=(<span class="type">int</span> *)a; <span class="comment">//强制类型转换并不会改变a 的类型</span></span><br><span class="line">p++;</span><br></pre></td></tr></table></figure><p>p是一个int类型的指针。</p><p>a是字符数组的头指针，a的类型是<code>char *</code>，强制转换为<code>int *</code>并赋值给p。</p><p>重点来了：<code>p++之后，指针p指向哪里？</code></p><p>这里并不是执行p+1，而编译器执行的真正操作是<code>p+sizeof(int)</code>。</p><p>因为p是int型的指针，int 占4 个字节。由于地址是用字节做单位的，故p所指向的地址向高地址方向增加了4 个字节。</p><p>由于char 类型的长度是一个字节，所以，原来p是指向数组a[0]，p++之后指向的是a[4]。</p>              </div>            </details><h2 id="指针运算符-和"><a href="#指针运算符-和" class="headerlink" title="指针运算符&amp;和*"></a>指针运算符&amp;和*</h2><details class="folding-tag" green open><summary> 来自自己 </summary>              <div class='content'>              <p>在我看指针运算符时一直是用的下面的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>, b;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">p = &amp;a;<span class="comment">//&amp;是取地址</span></span><br><span class="line">b = *p; <span class="comment">//*是取内容</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,value;</span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">//也可写成：value=*array;</span></span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">3</span>]; <span class="comment">//也可写成：value=*(array+3);</span></span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">4</span>]; <span class="comment">//也可写成：value=*(array+4);</span></span><br></pre></td></tr></table></figure><p>这个比较简单了，主要是记住数组名就代表数组头指针就行了。</p><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><details class="folding-tag" green open><summary> 来自CSDN-唐大麦 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *pa;</span><br><span class="line"><span class="type">int</span> **ptr;</span><br><span class="line"></span><br><span class="line">pa = &amp;a;</span><br><span class="line">ptr = &amp;pa;<span class="comment">//pa是int型指针，&amp;pa就是指针的指针</span></span><br><span class="line">*ptr = &amp;b;<span class="comment">//二级指针取内容，就是一个一级指针</span></span><br></pre></td></tr></table></figure><p>数组的二级指针例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *arr[<span class="number">20</span>];<span class="comment">//arr是char*指针类型的数组</span></span><br><span class="line"><span class="type">char</span> **parr = arr;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="字符串的指针表示（未来可能移动到字符串节）"><a href="#字符串的指针表示（未来可能移动到字符串节）" class="headerlink" title="字符串的指针表示（未来可能移动到字符串节）"></a>字符串的指针表示（未来可能移动到字符串节）</h2><details class="folding-tag" green open><summary> 来自CSDN-唐大麦 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str[<span class="number">3</span>]=&#123;</span><br><span class="line">    <span class="string">&quot;Hello,thisisasample!&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Hi,goodmorning.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Helloworld&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> s[<span class="number">80</span>]；</span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">0</span>]); <span class="comment">//也可写成strcpy(s,*str);</span></span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">1</span>]); <span class="comment">//也可写成strcpy(s,*(str+1));</span></span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">2</span>]); <span class="comment">//也可写成strcpy(s,*(str+2));</span></span><br></pre></td></tr></table></figure><p>记录一下字符串的表示方法，这种表示方法之前我见到过，但是后面忘记了。</p>              </div>            </details><h2 id="字符串与结构体"><a href="#字符串与结构体" class="headerlink" title="字符串与结构体"></a>字符串与结构体</h2><p><code>重点！</code></p><details class="folding-tag" green open><summary> 来自CSDN-唐大麦 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span>=</span>&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">//声明了结构对象ss，并把ss的成员初始化为20，30 和40。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">ptr</span>=</span>&amp;ss;</span><br><span class="line"><span class="comment">//声明了一个指向结构对象ss 的指针。它的类型是</span></span><br><span class="line"><span class="comment">//MyStruct *,它指向的类型是MyStruct。</span></span><br></pre></td></tr></table></figure><p>通过指针访问结构体成员变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a;</span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="函数和指针的关系"><a href="#函数和指针的关系" class="headerlink" title="函数和指针的关系"></a>函数和指针的关系</h2><details class="folding-tag" green open><summary> 来自自己 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*pfun)(<span class="type">char</span> *,<span class="type">int</span>);<span class="comment">//pfun是个函数指针</span></span><br><span class="line">pfun=fun;</span><br><span class="line"><span class="type">int</span> a=(*pfun)(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">7</span>); <span class="comment">//用运算符*取内容，后面加上形参就能调用函数了。</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h2><details class="folding-tag" green open><summary> 来自自己 </summary>              <div class='content'>              <p>举例，int类型的指针变成char类型指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line">a=<span class="number">0x12345678</span>;<span class="comment">//表示一个具体地址</span></span><br><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line">ptr=(<span class="type">char</span>*)a;</span><br></pre></td></tr></table></figure><p>举例：指针具体数值的提取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">123</span>,b;</span><br><span class="line"><span class="type">int</span> *ptr=&amp;a;</span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line">b=(<span class="type">int</span>)ptr; <span class="comment">//把指针ptr 的值当作一个整数取出来。</span></span><br><span class="line">str=(<span class="type">char</span>*)b; <span class="comment">//把这个整数的值当作一个地址赋给指针str。</span></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="指针安全"><a href="#指针安全" class="headerlink" title="指针安全"></a>指针安全</h2><details class="folding-tag" green open><summary> 来自CSDN-唐大麦 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line">ptr=(<span class="type">int</span> *)&amp;s;</span><br><span class="line">*ptr=<span class="number">1298</span>;</span><br></pre></td></tr></table></figure><p>指针原先是char型，只选定了一个字节，这样强制转换成int型导致指针选定了这个字节连带后面三个字节，总共四个字节。</p><p>假如后三个字节里原本存储着重要内容，那这一操作就有一定的危险。</p>              </div>            </details><h2 id="指针实用操作"><a href="#指针实用操作" class="headerlink" title="指针实用操作"></a>指针实用操作</h2><h3 id="函数传入数组与返回数组"><a href="#函数传入数组与返回数组" class="headerlink" title="函数传入数组与返回数组"></a>函数传入数组与返回数组</h3><p>一个数组要想传入函数内，或者被函数return出来，那么只能是利用函数的头指针。</p><p>例如力扣第一题两数之和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> *ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">                ans[<span class="number">0</span>] = i;</span><br><span class="line">                ans[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>导入的数组是nums，导出的数组是ans。</p><p>为什么不能int ans[2];呢？而是要用malloc申请内存？</p><p>因为函数的返回值是数组，<code>也就是需要返回一个指针</code>。</p><p><code>而局部变量的指针是无法被函数返回的。</code>，所以要么把ans数组拿出去，变成全局变量，要么就申请内存。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><details class="folding-tag" green open><summary> 内存就像黑暗森林 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l1</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l2</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    l1-&gt;val = <span class="number">2</span>;</span><br><span class="line">    l2-&gt;val = <span class="number">6</span>;</span><br><span class="line">    l1-&gt;next = l2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,l1-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,l1-&gt;next-&gt;val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,(<span class="type">int</span>)l1-&gt;next-&gt;next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,(<span class="type">int</span>)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;next-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">8126800</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>所以初始化节点一定要做到每个节点的每个成员都初始化，NULL也是人为赋予的，不是系统自动的。</p>              </div>            </details><details class="folding-tag" green open><summary> 来自我的力扣 </summary>              <div class='content'>              <p>第二题的两个倒序链表相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">addTwoNumbers</span><span class="params">(<span class="keyword">struct</span> ListNode* l1, <span class="keyword">struct</span> ListNode* l2)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 || l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c1 = l1? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> c2 = l2? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            node-&gt;val = (c1+c2+carry)%<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            node-&gt;val = (c1+c2+carry)%<span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(l2)l2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">        carry = (c1+c2+carry)/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));<span class="comment">//这四步其实可以看作一步，就简单了很多,代码模块化</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        node-&gt;val = carry;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实稍微复习一下，语法就能记起来了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br></pre></td></tr></table></figure><p>上面这句我甚至还想了一段时间。head是个指针，指向的就是<code>node这个链表头节点的地址</code>。</p><h3 id="初始化节点"><a href="#初始化节点" class="headerlink" title="初始化节点"></a>初始化节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));<span class="comment">//这四步其实可以看作一步，就简单了很多,代码模块化</span></span><br><span class="line">node = node-&gt;next;</span><br><span class="line">node-&gt;val = carry;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>这几句是一成不变的，必须连在一起，</p><p>三步初始化节点：</p><ol><li><p><code>给节点指针申请内存</code></p></li><li><p><code>节点连接</code></p></li><li><p><code>赋值</code></p></li></ol><p><code>然后写算法一定要打草稿。</code></p>              </div>            </details><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>该算法的适用关键词是：<code>子串</code>。</p><p>各种找怎么怎么样的子串都可以用这个算法。</p><p><code>子串问题套用这个算法就可以简化为：滑动窗口的左端和右端位置锁定的问题</code>。</p><p>以下是<strong>精炼的算法核心</strong>：</p><ul><li>如果当前子串不符合要求：<code>扩展右端</code>。</li><li>如果当前子串    符合要求：<code>收缩左端</code>。</li></ul><p>比如力扣第三题：无重复字符的最长子串。</p><details class="folding-tag" green open><summary> 来自我的力扣 </summary>              <div class='content'>              <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) a&gt;b? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,length = <span class="number">0</span>,max_l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>; s[right];right++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left ; i&lt;right ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left=i+<span class="number">1</span>;       </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        length = right+<span class="number">1</span> - left;</span><br><span class="line">        max_l = max(length,max_l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_l;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>比如找最长的回文子串这种，必须要把所有可能的子串全部遍历出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//R边界遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)<span class="comment">//L边界遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//得到[L,R]的子串</span></span><br><span class="line">        <span class="type">int</span> L = j;</span><br><span class="line">        <span class="type">int</span> R = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个循环遍历右边界，第二个循环遍历左边界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode配置C语言环境&quot;&gt;&lt;a href=&quot;#vscode配置C语言环境&quot; class=&quot;headerlink&quot; title=&quot;vscode配置C语言环境&quot;&gt;&lt;/a&gt;vscode配置C语言环境&lt;/h1&gt;&lt;p&gt;MinGW-W64 GCC下载链接：&lt;/p&gt;
&lt;di</summary>
      
    
    
    
    <category term="理论" scheme="https://sly3601.top/categories/%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="C" scheme="https://sly3601.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://sly3601.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【前端】个人博客开发日记 - 基于hexo+butterfly</title>
    <link href="https://sly3601.top/posts/204a3008.html"/>
    <id>https://sly3601.top/posts/204a3008.html</id>
    <published>2024-10-05T07:46:31.000Z</published>
    <updated>2024-10-06T17:20:28.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客开发日记"><a href="#个人博客开发日记" class="headerlink" title="个人博客开发日记"></a>个人博客开发日记</h1><h2 id="一、致谢"><a href="#一、致谢" class="headerlink" title="一、致谢"></a>一、致谢</h2><p>感谢安知鱼大佬，让我无痛使用框架快速搭建了博客，让我也体验了前端程序员的快乐~</p><div class="tag link"><a class="link-card" title="安知鱼：Butterfly重装日记" href="https://blog.anheyu.com/posts/sdxhu.html"><div class="left"><img src="/img/siteicon/64.png"/></div><div class="right"><p class="text">安知鱼：Butterfly重装日记</p><p class="url">https://blog.anheyu.com/posts/sdxhu.html</p></div></a></div><div class="tag link"><a class="link-card" title="糖果屋教程贴:Markdown语法与外挂标签写法汇总" href="https://www.fomal.cc/posts/2013454d.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴:Markdown语法与外挂标签写法汇总</p><p class="url">https://www.fomal.cc/posts/2013454d.html</p></div></a></div><h2 id="二、博客开发和前端学习暂时告一段落"><a href="#二、博客开发和前端学习暂时告一段落" class="headerlink" title="二、博客开发和前端学习暂时告一段落"></a>二、博客开发和前端学习暂时告一段落</h2><p>博客还有很多很多可以优化的地方，但是我毕竟不是这个方向的，能复制粘贴成这样已经非常满意了，后面我会多写博客，等以后有机会再优化网站。</p><h3 id="插入图片的方法"><a href="#插入图片的方法" class="headerlink" title="插入图片的方法"></a>插入图片的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/img/photos/QQ_1728132822728.png&quot; alt=&quot;示例图片&quot; style=&quot;zoom:100%;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>其中：style里面的zoom是图片缩放比例，100%就是不缩放，原图放在网页上。</p><img src="/img/photos/QQ_1728132822728.png" alt="示例图片" style="zoom:100%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;个人博客开发日记&quot;&gt;&lt;a href=&quot;#个人博客开发日记&quot; class=&quot;headerlink&quot; title=&quot;个人博客开发日记&quot;&gt;&lt;/a&gt;个人博客开发日记&lt;/h1&gt;&lt;h2 id=&quot;一、致谢&quot;&gt;&lt;a href=&quot;#一、致谢&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="实操" scheme="https://sly3601.top/categories/%E5%AE%9E%E6%93%8D/"/>
    
    
    <category term="hexo" scheme="https://sly3601.top/tags/hexo/"/>
    
    <category term="butterfly" scheme="https://sly3601.top/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>【项目】电机传感器网联模块开发日记</title>
    <link href="https://sly3601.top/posts/4935e6ca.html"/>
    <id>https://sly3601.top/posts/4935e6ca.html</id>
    <published>2024-10-05T07:46:31.000Z</published>
    <updated>2024-10-05T13:20:56.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电机传感器网联模块"><a href="#电机传感器网联模块" class="headerlink" title="电机传感器网联模块"></a>电机传感器网联模块</h1><p>就是个普通物联网项目，赶快做完，顺便记录下。</p><h2 id="ESP32的最小系统板PCB绘制"><a href="#ESP32的最小系统板PCB绘制" class="headerlink" title="ESP32的最小系统板PCB绘制"></a>ESP32的最小系统板PCB绘制</h2><details class="folding-tag" green open><summary> esp32模块 </summary>              <div class='content'>              <div class='checkbox green'><input type="checkbox" />            <ol><li>sd卡模块验证</li></ol>            </div><div class='checkbox green'><input type="checkbox" />            <ol start="2"><li>esp32s3模块的封装</li></ol>            </div><div class='checkbox green'><input type="checkbox" />            <ol start="3"><li>esp32+信号采集+电源+SD卡PCB绘制</li></ol>            </div><div class='checkbox green'><input type="checkbox" />            <ol start="4"><li>sd卡实时存储数据</li></ol>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <ol start="5"><li>esp32与app收发数据</li></ol>            </div>              </div>            </details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电机传感器网联模块&quot;&gt;&lt;a href=&quot;#电机传感器网联模块&quot; class=&quot;headerlink&quot; title=&quot;电机传感器网联模块&quot;&gt;&lt;/a&gt;电机传感器网联模块&lt;/h1&gt;&lt;p&gt;就是个普通物联网项目，赶快做完，顺便记录下。&lt;/p&gt;
&lt;h2 id=&quot;ESP32的最</summary>
      
    
    
    
    <category term="实操" scheme="https://sly3601.top/categories/%E5%AE%9E%E6%93%8D/"/>
    
    
    <category term="esp32" scheme="https://sly3601.top/tags/esp32/"/>
    
    <category term="阿里云" scheme="https://sly3601.top/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="android" scheme="https://sly3601.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【理论】《ARM cortex-M3权威指南》学习笔记</title>
    <link href="https://sly3601.top/posts/72c3f755.html"/>
    <id>https://sly3601.top/posts/72c3f755.html</id>
    <published>2024-10-04T07:46:31.000Z</published>
    <updated>2024-10-06T03:32:52.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《ARM-cortex-M3权威指南》学习笔记"><a href="#《ARM-cortex-M3权威指南》学习笔记" class="headerlink" title="《ARM cortex-M3权威指南》学习笔记"></a>《ARM cortex-M3权威指南》学习笔记</h1><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>是时候把单片机开发学得再深入一些了。我希望自己之后的开发能深入到内核和汇编层面，自然要多补充一些理论基础。好的</p>]]></content>
    
    
    <summary type="html">轮足机器人开发过程记录</summary>
    
    
    
    <category term="理论" scheme="https://sly3601.top/categories/%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="cortex-M3" scheme="https://sly3601.top/tags/cortex-M3/"/>
    
    <category term="stm32" scheme="https://sly3601.top/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>【项目】轮足机器人开发日记</title>
    <link href="https://sly3601.top/posts/cac2c8f1.html"/>
    <id>https://sly3601.top/posts/cac2c8f1.html</id>
    <published>2024-10-04T07:46:31.000Z</published>
    <updated>2024-10-11T16:05:50.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮足机器人"><a href="#轮足机器人" class="headerlink" title="轮足机器人"></a>轮足机器人</h1><p>因为制作博客之前这个项目就已经做了很多了，所以就先写新的。</p><h2 id="CAN总线通信"><a href="#CAN总线通信" class="headerlink" title="CAN总线通信"></a>CAN总线通信</h2><details class="folding-tag" green open><summary> CAN总线通信filter </summary>              <div class='content'>              <p>上位机是STM32H743IIT6，下位机是两个STM32F103C8T6。</p><p>重点是filter的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN CAN_Init 2 */</span></span><br><span class="line">CAN_FilterTypeDef can_filtercfg;</span><br><span class="line">can_filtercfg.FilterMode = CAN_FILTERMODE_IDMASK;<span class="comment">//屏蔽位模式</span></span><br><span class="line">can_filtercfg.FilterScale = CAN_FILTERSCALE_32BIT;</span><br><span class="line">can_filtercfg.FilterIdHigh = <span class="number">0x12</span>&lt;&lt;<span class="number">5</span>;<span class="comment">//ID</span></span><br><span class="line">can_filtercfg.FilterIdLow = <span class="number">0</span>;</span><br><span class="line">can_filtercfg.FilterMaskIdHigh = <span class="number">0x7FF</span>;</span><br><span class="line">can_filtercfg.FilterMaskIdLow = <span class="number">0x06</span>;</span><br><span class="line"></span><br><span class="line">can_filtercfg.FilterBank = <span class="number">0</span>;<span class="comment">//过滤器组0</span></span><br><span class="line">can_filtercfg.FilterFIFOAssignment = CAN_FILTER_FIFO0;</span><br><span class="line">can_filtercfg.FilterActivation = CAN_FILTER_ENABLE;</span><br><span class="line">can_filtercfg.SlaveStartFilterBank = <span class="number">14</span>;<span class="comment">//如果只使用单个CAN，可忽略此成员取值：0 ~ 27</span></span><br><span class="line"><span class="keyword">while</span>(HAL_CAN_ConfigFilter(&amp;hcan, &amp;can_filtercfg)!=HAL_OK);</span><br><span class="line"><span class="comment">/* USER CODE END CAN_Init 2 */</span></span><br></pre></td></tr></table></figure><p>我的两个电机id分别是0x12和0x13，目前只接受不发送。</p>              </div>            </details><details class="folding-tag" green open><summary> CAN总线通信CPU占用 </summary>              <div class='content'>              <p>我一直担心的一点是：can通信要以2ms的频率发送一帧8个字节的标准数据帧，2ms的频率接收一帧8个字节的标准数据帧，我担心CPU会不会吃不消？</p><p>但是通过简单搜集资料：</p><p>CAN通信外设的发送和接收都是非阻塞的，也就是can通信的bit位收发都是由外设自己处理的，不经过CPU，这样就无从谈起CPU占用率。</p><img src="https://s2.loli.net/2024/10/10/H41QBojPJXCeg2y.png" alt="CAN通信外设模型" style="zoom:100%;" /><p>即使bit位的发送和接收就是走的CPU，我们经过如下计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">CAN 通信标准数据帧包含以下部分：</span><br><span class="line"></span><br><span class="line">• 帧起始（1 比特）。</span><br><span class="line"></span><br><span class="line">• 11 位标识符。</span><br><span class="line"></span><br><span class="line">• 1 位远程发送请求位（RTR）。</span><br><span class="line"></span><br><span class="line">• 2 位控制域。</span><br><span class="line"></span><br><span class="line">• 8 个字节的数据域，1 个字节等于 8 比特，所以数据域为 8×8 = 64 比特。</span><br><span class="line"></span><br><span class="line">• 15 位循环冗余校验（CRC）序列。</span><br><span class="line"></span><br><span class="line">• 1 位 CRC 界定符。</span><br><span class="line"></span><br><span class="line">• 1 位应答位（ACK）。</span><br><span class="line"></span><br><span class="line">• 1 位应答界定符。</span><br><span class="line"></span><br><span class="line">• 7 位帧结束。</span><br><span class="line"></span><br><span class="line">将各部分比特数相加：1 + 11 + 1 + 2 + 64 + 15 + 1 + 1 + 1 + 7 = 104 比特。</span><br><span class="line"></span><br><span class="line">所以，CAN 通信发一次含八个字节的标准数据帧总共需要发 104 比特。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">已知通信速率是 1M（1Mbps，即每秒 1000000 比特）。</span><br><span class="line"></span><br><span class="line">1. 总比特数：</span><br><span class="line"></span><br><span class="line">• 八个字节的标准数据帧总共 104 比特。</span><br><span class="line"></span><br><span class="line">2. 耗时计算：</span><br><span class="line"></span><br><span class="line">• 时间 = 数据量（比特数）÷ 速率。</span><br><span class="line"></span><br><span class="line">• 耗时 = 104÷1000000 = 0.000104 秒。</span><br><span class="line"></span><br><span class="line">综上所述，含八个字节的标准数据帧总共 104 比特，耗时 0.000104 秒。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 计算发送和接收一帧数据的总时间：</span><br><span class="line"></span><br><span class="line">• 发送一帧数据耗时 0.000104 秒。</span><br><span class="line"></span><br><span class="line">• 接收一帧数据耗时同样为 0.000104 秒。</span><br><span class="line"></span><br><span class="line">• 总耗时为 0.000104×2 = 0.000208 秒（因为既要发送又要接收）。</span><br><span class="line"></span><br><span class="line">2. 计算在 2ms 内处理 CAN 通信数据的时间比例：</span><br><span class="line"></span><br><span class="line">• 2ms = 0.002 秒。</span><br><span class="line"></span><br><span class="line">• 处理 CAN 通信数据的时间比例为 0.000208÷0.002 = 0.104。</span><br><span class="line"></span><br><span class="line">3. 换算成 CPU 占用率：</span><br><span class="line"></span><br><span class="line">• CPU 占用率约为 0.104×100% = 10.4% 。</span><br><span class="line">也就是最差最差，CPU也只占用了10%.所以没什么好担心的，我就是完全被那个买来的破CAN上位机吓傻了。</span><br></pre></td></tr></table></figure><p>经过实际测试：</p><p>没有加can发送的电机速度波动如下：</p><img src="https://s2.loli.net/2024/10/11/E7IWg81bC2HXrqf.jpg" alt="没加CAN发送的速度波动" style="zoom:60%;" /><p>加了can发送四个字节的pid速度环反应如下：</p><img src="https://s2.loli.net/2024/10/11/3nCqobT1kRsjJ9G.jpg" alt="加了CAN发送的速度波动" style="zoom:55%;" /><p>能看到电机启动的波动有一些增大。说明can发送可能确实会加重对线程占用的负担。。。糟糕</p><p><code>我打算对这个现象多搜集资料，要明确can通信对于线程占用的影响。</code></p>              </div>            </details><h2 id="无刷电机PID"><a href="#无刷电机PID" class="headerlink" title="无刷电机PID"></a>无刷电机PID</h2><details class="folding-tag" green open><summary> PID速度环 </summary>              <div class='content'>              <p>首先是速度的计算频率，经过实验，4000线的编码器最适合的速度计算周期是50ms，计算频率太小和太大都会影响速度计算。</p><p><code>电机低速段的编码器测速方法可能需要换，比如T法测速</code>，这个待查。</p><p>PID速度环我是只用了纯P控制，做到快速无超调达到目标速度。因为轮足的轮只是大致达到速度要求即可，没那么高精度要求，所以我就没加I。</p><p>其实这种平衡小车的电机应该是PD控制，确保最大的快速性，不能加I，不能让电机迟滞，这跟普通的汽车轮子是完全不一样的。</p>              </div>            </details><h2 id="平衡PID（与平衡小车一致）"><a href="#平衡PID（与平衡小车一致）" class="headerlink" title="平衡PID（与平衡小车一致）"></a>平衡PID（与平衡小车一致）</h2><details class="folding-tag" green open><summary> 直立环+速度环 </summary>              <div class='content'>              <img src="https://s2.loli.net/2024/10/12/Tm5qH97PQhcwCpj.jpg" alt="加了CAN发送的速度波动" style="zoom:100%;" /><ul><li><p>a_m1是速度环PID输出</p></li><li><p>pid_out是直立环PID输出</p></li></ul><p>里面的杂点是ozone的bug，不用管。可以看到：</p><p><code>速度环其实是在对直立环进行抑制。</code></p>              </div>            </details>]]></content>
    
    
    <summary type="html">轮足机器人开发过程记录</summary>
    
    
    
    <category term="实操" scheme="https://sly3601.top/categories/%E5%AE%9E%E6%93%8D/"/>
    
    
    <category term="stm32" scheme="https://sly3601.top/tags/stm32/"/>
    
    <category term="CAN通信" scheme="https://sly3601.top/tags/CAN%E9%80%9A%E4%BF%A1/"/>
    
    <category term="solidworks" scheme="https://sly3601.top/tags/solidworks/"/>
    
  </entry>
  
  <entry>
    <title>【日记】一只猪的诞生</title>
    <link href="https://sly3601.top/posts/301ff190.html"/>
    <id>https://sly3601.top/posts/301ff190.html</id>
    <published>2024-10-04T06:02:37.000Z</published>
    <updated>2024-10-05T13:20:58.608Z</updated>
    
    <content type="html"><![CDATA[<script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><h1 id="Our-story-begins"><a href="#Our-story-begins" class="headerlink" title="Our story begins."></a>Our story begins.</h1><h2 id="一、我的个人网站的诞生"><a href="#一、我的个人网站的诞生" class="headerlink" title="一、我的个人网站的诞生"></a>一、我的个人网站的诞生</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> main&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切的开始都是在刚上大二的那个迷茫的秋天。</p><div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>一路走来</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2024-10-04 [研二]</p></div></div><div class='timeline-item-content'><p>我搭建了自己的个人博客网站。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2024-08-01 [研一]</p></div></div><div class='timeline-item-content'><p>导师那边，会议论文总算是写完了，专硕毕业条件达到了。继续做产品，但是换个团队。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2024-03-01 [研一]</p></div></div><div class='timeline-item-content'><p>深圳科创学院实习开始，做超声波电路、做各种家电的电路、电机驱动、STM32开发、ESP32物联网开发。同时分手。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2024-02-01 [研一]</p></div></div><div class='timeline-item-content'><p>深圳科创学院冬令营！嗯，第一次从村里进城，我确实是原始人。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-10-26 [研一]</p></div></div><div class='timeline-item-content'><p>脱单。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-09 [研一]</p></div></div><div class='timeline-item-content'><p>飞机在盘旋降落，横摆角roll比较大。这个刁钻的视角也是让我这个小镇做题家看到了满山灯火的壮观场面。</p><p>你好~深圳！</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-07-16 [-]</p></div></div><div class='timeline-item-content'><p>再见唐岛湾。再见。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-04-01 [大四下]</p></div></div><div class='timeline-item-content'><p>毕设是FOC，差不多做完了。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-12-01 [大四寒假]</p></div></div><div class='timeline-item-content'><p>做毕设，也做机器人，做技术教学。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-10-28 [大四上]</p></div></div><div class='timeline-item-content'><p>脱单，在那个梦幻的夜晚，烟花绽放的瞬间。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-09-28 [大四上]</p></div></div><div class='timeline-item-content'><p>保研成功，心情很平静，好像啥都没变。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-08-22 [大三暑假]</p></div></div><div class='timeline-item-content'><p>我唯一在做的比赛是机创赛，因为队友是我为数不多信得过的好朋友。机创国二。交通赛也是没出多少力，学弟学妹拿了国三。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-22 [大三下]</p></div></div><div class='timeline-item-content'><p>我似乎是抑郁了，心理出大问题，以至于我退了智能车比赛，什么都退了，除了室友谁都不见，度日如年。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-03-22 [大三下]</p></div></div><div class='timeline-item-content'><p>天天做核酸，我天天在实验室学习。有一次我一整天在实验室通宵了，一天没见人，就没去做。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-12-22 [大三上]</p></div></div><div class='timeline-item-content'><p>沾沾自喜的我，基本上不管国际水下机器人比赛了，yolo识别物块还没搞出来，但是我也不想搞了，只得了国三。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-12-12 [大三上]</p></div></div><div class='timeline-item-content'><p>我独自在特种设备实验室看国足踢日本的世预赛，突然电赛成绩出来了，看一眼。卧槽国一！</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-11-12 [大三上]</p></div></div><div class='timeline-item-content'><p>干活干活，熬电赛！</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-8-15 [大二下]</p></div></div><div class='timeline-item-content'><p>我抓住了唯一引荐自己的机会，进了工训中心，真正开始试着做机器人，我开始搞电机控制，PID控制。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-8-5 [大二下]</p></div></div><div class='timeline-item-content'><p>Chem-E-Car国赛两周后。</p><p>我一想起小车在赛道上一直跑就难受，继电器失控是我完全无法理解的问题…</p><p>好在另一边，互联网+省赛金奖，虽然我只协助做着电控技术，位次排个第七，但是还是十分开心。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-5-5 [大二下]</p></div></div><div class='timeline-item-content'><p>我熬了五天大夜，整个人萎靡了，五一假期哪都没去，在实验室做着STM32的项目，学长并没有给我明确的学习路线，我一上来就要看ucosiii操作系统的源码、emwin的使用、数据结构写算法。这让我很迷茫，但是也乐此不疲，我还学了焊电路板。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-3-1 [大二寒假]</p></div></div><div class='timeline-item-content'><p>我无心在校园墙发了求比赛组队的帖子，结果被新能源学院的一个大佬看到了，他跟我同级，但是已经确定保研上交了，我好像抓住了救命稻草似的，不管他们是什么科研项目，一口答应进组。这个团队做的项目是特种设备无损寿命检测，我被一个大四学长带着，他让我学STM32，所以我就买了一块正点原子的mini开发板。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2021-2-1 [大二上]</p></div></div><div class='timeline-item-content'><p>要放寒假了，但是我还不想走，在为了Chem-E-Car校赛做准备，我也不知道做这些有什么用，但是还是尽量跟着学。</p><p>我自学了arduino，会点灯，会控制舵机，开心了好一阵。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-12-17 [大二上]</p></div></div><div class='timeline-item-content'><p>大一的老室友一起给我过了生日。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-12-15 [大二上]</p></div></div><div class='timeline-item-content'><p>科创比赛之路四处碰壁，自己学院不要我。我只好去别的学院找，我找到了化学工程学院，参加了第一个比赛：中国大学生Chem-E-Car竞赛</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-10-05 [大二上]</p></div></div><div class='timeline-item-content'><p>我动力满满，不知疲倦，开始各种各样的尝试：志愿服务、学生工作、科技比赛、声乐队、写论文…</p><p>10月5号这一天我进了学校里第一个组织：校团委实践中心，是都学姐拉我进去的。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-08-31 [大二上]</p></div></div><div class='timeline-item-content'><p>八个月没去学校，终于开学了。我又回到了这个熟悉又陌生的地方，女朋友没了，好朋友也因为专业分流联系少了，成绩也完蛋了，我没有朋友，没有成绩，没有目标，没有能力。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-06-31 [大一暑假]</p></div></div><div class='timeline-item-content'><p>考科二之前我决定：“如果这次过了，那么我就好好努力。如果没过，那我就一直摆烂下去吧。”<br>我考驾照成功过了科目二。我已经好久好久没有这样成功的快感，原来自己不是什么都做不好。<br>这个决定是一切的开始。</p></div></div></div>]]></content>
    
    
    <summary type="html">本站的第一个帖子</summary>
    
    
    
    <category term="日记" scheme="https://sly3601.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="日记" scheme="https://sly3601.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
